{"version":3,"sources":["Block.js.input.js"],"names":["tt","findCenterOfBlocks","arr","avgDFH","0","avgAngle","i","length","distFromHex","ang","angle","360","x","y","wx","globalData","trueCanvas","width","2","Math","cos","PI","180","height","sin","Block","'../settings.js'","'../comon.js'","console","log","'Block.js 导入的 settings:'","settings","blockHeight","constructor","hex","fallingLane","color","iter","settled","this","canvas","ctx","1","checked","90","30","60","angularVelocity","targetAngle","deleted","removed","tint","opacity","initializing","ict","ct","initLen","creationDt","attachedLane","startDist","scale","incrementOpacity","0.925","tLane","position","sides","shakes","push","3","currentPixelRatio","0.075","dt","gameState","getIndex","parentArr","blocks","draw","attached","index","0.000000001","abs","prevScale","angularVelocityConst","sqrt","widthWide","rat","p1","rotatePoint","p2","p3","p4","fillStyle","\"#FFF\"","globalAlpha","baseX","gdx","baseY","gdy","beginPath","moveTo","lineTo","closePath","fill","strokeStyle","'#000000'","lineWidth","stroke","2.25","0.02"],"mappings":"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","file":"Block.js","sourcesContent":["import { settings} from '../settings.js';\r\nimport { rotatePoint } from '../comon.js';\r\nconsole.log('Block.js 导入的 settings:', settings,settings.blockHeight);\r\nconst tt = wx\r\nclass Block {\r\n\tconstructor(hex,fallingLane, color, iter, distFromHex, settled) {\r\n\t\t//console.log(\"Block\",hex,fallingLane,color,iter,distFromHex,settled);\r\n\t\t/**\r\n\t\t * @type {Hex}\r\n\t\t */\r\n\t\tthis.hex = hex;\r\n\t\tthis.canvas = wx.globalData.canvas;\r\n\t\tthis.ctx = wx.globalData.ctx;\r\n\t\t// 是否已安置在中心六边形或其他块上\r\n\t\tthis.settled = (settled === undefined) ? 0 : 1;\r\n\t\t// 块的高度\r\n\t\tthis.height = settings.blockHeight;\r\n\t\t// 块从哪个通道掉落\r\n\t\tthis.fallingLane = fallingLane;\r\n\t\t// 块是否已检查\r\n\t\tthis.checked = 0;\r\n\t\t// 块掉落的角度\r\n\t\tthis.angle = 90 - (30 + 60 * fallingLane);\r\n\t\t// 用于计算附加到中心六边形的块的旋转\r\n\t\tthis.angularVelocity = 0;\r\n\t\tthis.targetAngle = this.angle;\r\n\t\t// 块的颜色\r\n\t\tthis.color = color;\r\n\t\t// 标记为删除的块\r\n\t\tthis.deleted = 0;\r\n\t\t// 标记为从掉落中移除并添加到六边形的块\r\n\t\tthis.removed = 0;\r\n\t\t// 用于绘制在掉落块上的白色块的不透明度值，以使其在附加到六边形时发光\r\n\t\tthis.tint = 0;\r\n\t\t// 用于删除动画的不透明度值\r\n\t\tthis.opacity = 1;\r\n\t\t// 块是否正在初始化，从小变大\r\n\t\tthis.initializing = 1;\r\n\t\t// 当前时间\r\n\t\tthis.ict = hex.ct;\r\n\t\t// 块的速度\r\n\t\tthis.iter = iter;\r\n\t\t// 在开始掉落之前的初始化时间\r\n\t\tthis.initLen = settings.creationDt;\r\n\t\t// 块附加到的边\r\n\t\tthis.attachedLane = 0;\r\n\t\t// 距离中心六边形的距离\r\n\t\tthis.distFromHex = distFromHex || settings.startDist * settings.scale;\r\n\t\r\n\t}\r\n\t// 增加不透明度\r\n    incrementOpacity() {\r\n        if (this.deleted) {\r\n            // 添加震动效果\r\n            if (this.opacity >= 0.925) {\r\n                var tLane = this.attachedLane - this.hex.position;\r\n                tLane = this.hex.sides - tLane;\r\n                while (tLane < 0) {\r\n                    tLane += this.hex.sides;\r\n                }\r\n\r\n                tLane %= this.hex.sides;\r\n                this.hex.shakes.push({lane: tLane, magnitude: 3 * (wx.globalData.currentPixelRatio ? wx.globalData.currentPixelRatio : 1) * (settings.scale)});\r\n            }\r\n            // 渐隐不透明度\r\n            this.opacity = this.opacity - 0.075 * this.hex.dt;\r\n            if (this.opacity <= 0) {\r\n                // 标记为最终删除\r\n                this.opacity = 0;\r\n                this.deleted = 2;\r\n                if (wx.globalData.gameState == 1 || wx.globalData.gameState == 0) {\r\n                    //localStorage.setItem(\"saveState\", exportSaveState());\r\n                }\r\n            }\r\n        }\r\n    };\r\n\t// 获取块在其堆栈中的索引\r\n    getIndex() {\r\n        var parentArr = this.hex.blocks[this.attachedLane];\r\n        for (var i = 0; i < parentArr.length; i++) {\r\n            if (parentArr[i] == this) {\r\n                return i;\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n\t\t// 计算四个顶点\r\n\t\t//       p1 -------- p2     ← width\r\n\t\t\t//   /          \\\r\n\t\t\t//  /            \\     ← 斜边\r\n\t\t\t// /              \\\r\n\t\t\t//p4 -------------- p3   ← widthWide\r\n\t\t // 绘制块\r\n\r\n\tdraw(attached, index) {\r\n\t\t//console.log(\"draw block\",this.height,settings.blockHeight);\r\n\t\t\r\n\t\tif (Math.abs(settings.scale - settings.prevScale) > 0.000000001) {\r\n\t\t\tthis.distFromHex *= (settings.scale/settings.prevScale);\r\n\t\t}\r\n\r\n\t\tthis.incrementOpacity();\r\n\t\tif(attached === undefined)\r\n\t\t\tattached = false;\r\n\r\n\t\tif(this.angle > this.targetAngle) {\r\n\t\t\tthis.angularVelocity -= wx.globalData.angularVelocityConst * this.hex.dt;\r\n\t\t}\r\n\t\telse if(this.angle < this.targetAngle) {\r\n\t\t\tthis.angularVelocity += wx.globalData.angularVelocityConst * this.hex.dt;\r\n\t\t}\r\n\r\n\t\tif (Math.abs(this.angle - this.targetAngle + this.angularVelocity) <= Math.abs(this.angularVelocity)) { //do better soon\r\n\t\t\tthis.angle = this.targetAngle;\r\n\t\t\tthis.angularVelocity = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.angle += this.angularVelocity;\r\n\t\t}\r\n\t\t\r\n\t\tthis.width = 2 * this.distFromHex / Math.sqrt(3);\r\n\t\tthis.widthWide = 2 * (this.distFromHex + this.height) / Math.sqrt(3);\r\n\t\t//this.widthWide = this.width + this.height + 3;\r\n\t\tvar p1;\r\n\t\tvar p2;\r\n\t\tvar p3;\r\n\t\tvar p4;\r\n\t\t//从小到大的动画\r\n\t\tif (this.initializing) {\r\n\t\t\tvar rat = ((this.hex.ct - this.ict)/this.initLen);\r\n\t\t\tif (rat > 1) {\r\n\t\t\t\trat = 1;\r\n\t\t\t}\r\n\t\t\tp1 = rotatePoint((-this.width / 2) * rat, this.height / 2, this.angle);\r\n\t\t\tp2 = rotatePoint((this.width / 2) * rat, this.height / 2, this.angle);\r\n\t\t\tp3 = rotatePoint((this.widthWide / 2) * rat, -this.height / 2, this.angle);\r\n\t\t\tp4 = rotatePoint((-this.widthWide / 2) * rat, -this.height / 2, this.angle);\r\n\t\t\tif ((this.hex.ct - this.ict) >= this.initLen) {\r\n\t\t\t\tthis.initializing = 0;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tp1 = rotatePoint(-this.width / 2, this.height / 2, this.angle);\r\n\t\t\tp2 = rotatePoint(this.width / 2, this.height / 2, this.angle);\r\n\t\t\tp3 = rotatePoint(this.widthWide / 2, -this.height / 2, this.angle);\r\n\t\t\tp4 = rotatePoint(-this.widthWide / 2, -this.height / 2, this.angle);\r\n\t\t}\r\n\r\n\t\tif (this.deleted) {\r\n\t\t\tthis.ctx.fillStyle = \"#FFF\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.ctx.fillStyle = this.color;\r\n\t\t}\r\n\r\n\t\tthis.ctx.globalAlpha = this.opacity;\r\n\t\tvar baseX = wx.globalData.trueCanvas.width / 2 + Math.sin((this.angle) * (Math.PI / 180)) * (this.distFromHex + this.height / 2) + wx.globalData.gdx;\r\n\t\tvar baseY = wx.globalData.trueCanvas.height / 2 - Math.cos((this.angle) * (Math.PI / 180)) * (this.distFromHex + this.height / 2) + wx.globalData.gdy;\r\n\t\tthis.ctx.beginPath();\r\n\t\tthis.ctx.moveTo(baseX + p1.x, baseY + p1.y);\r\n\t\tthis.ctx.lineTo(baseX + p2.x, baseY + p2.y);\r\n\t\tthis.ctx.lineTo(baseX + p3.x, baseY + p3.y);\r\n\t\tthis.ctx.lineTo(baseX + p4.x, baseY + p4.y);\r\n\t\t//ctx.lineTo(baseX + p1.x, baseY + p1.y);\r\n\t\tthis.ctx.closePath();\r\n\t\tthis.ctx.fill();\r\n\r\n\t\t// 添加黑色边框\r\n\t\tthis.ctx.strokeStyle = '#000000';  // 设置边框颜色为黑色\r\n\t\tthis.ctx.lineWidth = 1;  // 设置边框宽度\r\n\t\tthis.ctx.stroke();  // 绘制边框\r\n\r\n\t\tif (this.tint) {\r\n\t\t\tif (this.opacity < 1) {\r\n\t\t\t\tthis.iter = 2.25;\r\n\t\t\t\tthis.tint = 0;\r\n\t\t\t}\r\n\r\n\t\t\tthis.ctx.fillStyle = \"#FFF\";\r\n\t\t\tthis.ctx.globalAlpha = this.tint;\r\n\t\t\tthis.ctx.beginPath();\r\n\t\t\tthis.ctx.moveTo(baseX + p1.x, baseY + p1.y);\r\n\t\t\tthis.ctx.lineTo(baseX + p2.x, baseY + p2.y);\r\n\t\t\tthis.ctx.lineTo(baseX + p3.x, baseY + p3.y);\r\n\t\t\tthis.ctx.lineTo(baseX + p4.x, baseY + p4.y);\r\n\t\t\tthis.ctx.lineTo(baseX + p1.x, baseY + p1.y);\r\n\t\t\tthis.ctx.closePath();\r\n\t\t\tthis.ctx.fill();\r\n\t\t\tthis.tint -= 0.02 * this.hex.dt;\r\n\t\t\tif (this.tint < 0) {\r\n\t\t\t\tthis.tint = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.ctx.globalAlpha = 1;\r\n\t};\r\n}\r\n/**\r\n * @param {Array<Block>} arr \r\n * @returns {{x: number, y: number}}\r\n */\r\nfunction findCenterOfBlocks(arr) {\r\n\tvar avgDFH = 0;\r\n\tvar avgAngle = 0;\r\n\tfor (var i = 0; i < arr.length; i++) {\r\n\t\tavgDFH += arr[i].distFromHex;\r\n\t\tvar ang = arr[i].angle;\r\n\t\twhile (ang < 0) {\r\n\t\t\tang += 360;\r\n\t\t}\r\n\t\t\r\n\t\tavgAngle += ang % 360;\r\n\t}\r\n\r\n\tavgDFH /= arr.length;\r\n\tavgAngle /= arr.length;\r\n\r\n\treturn {\r\n\t\tx:wx.globalData.trueCanvas.width/2 + Math.cos(avgAngle * (Math.PI / 180)) * avgDFH,\r\n\t\ty:wx.globalData.trueCanvas.height/2 + Math.sin(avgAngle * (Math.PI / 180)) * avgDFH\r\n\t};\r\n}\r\n\r\nexport default Block;\r\nexport {findCenterOfBlocks}"]}